#include <vector>
#include <map>
#pragma once
template<typename ACCESSOR>
class HashLookup{
public:
    typedef typename ACCESSOR::Value value;
    typedef typename ACCESSOR::DATATYPE DATATYPE;
    typedef unsigned long long BIDTYPE;

    template<typename LSHTYPE>
    HashLookup(
        const DATATYPE* domin,
        lshbox::Scanner<ACCESSOR>& scanner,
        LSHTYPE& mylsh) : scanner_(scanner) {

        scanner_.reset(domin);
        hashBits_ = mylsh.getHashBits(0, domin);
        numBits_ = hashBits_.size();

        std::vector<bool> ptb(numBits_, 0);
        PTB_.push_back(ptb);
    }

    BIDTYPE getNextBID() {
        numBucketsProbed_++;
        std::vector<bool> nextptb = getNextPTB_();

        // cal next bucket based on hashVal and perturbation
        BIDTYPE newBucket = 0;
        for (int i = 0; i < hashBits_.size(); ++i) {
            newBucket <<= 1;
            if (nextptb[i] == true) {
                newBucket += 1 - hashBits_[i];
            } else {
                newBucket += hashBits_[i];
            }
        }
        return newBucket;
    }

    void operator()(unsigned key){
        numItemsProbed_++;
        // scanner_(key);
    }

    void reportCDD(){
        // report probed items
        lshbox::Scanner<ACCESSOR> thisScan = scanner_;
        thisScan.topk().genTopk();
        std::vector<std::pair<float, unsigned>> topk 
            = thisScan.topk().getTopk();
    }

    lshbox::Scanner<ACCESSOR> getScanner(){
        return scanner_;
    }

    int getNumItemsProbed() { // get number of items probed;
        return numItemsProbed_;
    }

    bool nextBucketExisted() {
        if (R_ == numBits_ && idxToPTB_ == PTB_.size() - 1) {
            return false;
        } else {
            return true;
        }
    }

    int getNumBits() {
        return numBits_;
    }

protected:
    // each query maintains its PTB_
    unsigned long long idxToPTB_ = 0; // can be inherited
    virtual std::vector<bool> getNextPTB_() {
        if (idxToPTB_ >= PTB_.size()) {
            // generate possible buckets whose distance to q is R
            assert(R_ < numBits_);
            std::vector<std::vector<bool>> newPTB;
            for (auto& ptb : PTB_) {
                // find largest idx that is 1
                int idx = -1;
                for (int i = ptb.size() - 1; i >=0; --i) { 
                    if (ptb[i] == true) {
                        idx = i;
                        break;
                    }
                }
                for (int i = idx + 1; i < numBits_; ++i) {
                    std::vector<bool> newptb = ptb;
                    newptb[i] = true;
                    newPTB.push_back(newptb);
                }
            }
            // digui chansheng: the r-distance buckets are generated by previous buckets
            PTB_ = newPTB;
            idxToPTB_ = 0;
            R_++;
        }
        return PTB_[idxToPTB_++];
    }

private:
    std::vector<std::vector<bool>> PTB_; 
    int R_ = 0;
    std::vector<bool> hashBits_;
    unsigned long long numBucketsProbed_ = 0;
    int numItemsProbed_ = 0;
    lshbox::Scanner<ACCESSOR> scanner_;
    int numBits_;  
};
