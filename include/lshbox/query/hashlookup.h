#include <vector>
#include <map>
#pragma once
template<typename ACCESSOR>
class HashLookup : public Prober<ACCESSOR>{
public:
    typedef typename ACCESSOR::Value value;
    typedef typename ACCESSOR::DATATYPE DATATYPE;
    typedef typename Prober<ACCESSOR>::BIDTYPE BIDTYPE;

    template<typename LSHTYPE>
    HashLookup(
        const DATATYPE* domin,
        lshbox::Scanner<ACCESSOR>& scanner,
        LSHTYPE& mylsh) : Prober<ACCESSOR>(domin, scanner, mylsh) {

        table_ = 0;
        std::vector<bool> ptb(this->R_, 0);
        PTB_.push_back(ptb);
    }

    std::pair<unsigned, BIDTYPE> getNextBID() {
        this->numBucketsProbed_++;
        if (table_ == this->hashBits_.size()) {
            table_ = 0;
        }
        if (table_ == 0) {
            curPTB_ = getNextPTB_();
        }

        // cal next bucket based on hashVal and perturbation
        BIDTYPE newBucket = 0;
        for (unsigned i = 0; i < this->R_; ++i) {
            newBucket <<= 1;
            if (curPTB_[i] == true) {
                newBucket += 1 - this->hashBits_[table_][i];
            } else {
                newBucket += this->hashBits_[table_][i];
            }
        }
        std::pair<unsigned, BIDTYPE> result = std::make_pair(table_, newBucket);
        table_++;

        return result;
    }

protected:
    // each query maintains its PTB_
    unsigned long long idxToPTB_ = 0; // can be inherited
    virtual std::vector<bool> getNextPTB_() {
        if (idxToPTB_ >= PTB_.size()) {
            // generate possible buckets whose distance to q is R
            assert(this->R_ < this->R_);
            std::vector<std::vector<bool>> newPTB;
            for (auto& ptb : PTB_) {
                // find largest idx that is 1
                int idx = -1;
                for (int i = ptb.size() - 1; i >=0; --i) { 
                    if (ptb[i] == true) {
                        idx = i;
                        break;
                    }
                }
                for (int i = idx + 1; i < this->R_; ++i) {
                    std::vector<bool> newptb = ptb;
                    newptb[i] = true;
                    newPTB.push_back(newptb);
                }
            }
            // digui chansheng: the r-distance buckets are generated by previous buckets
            PTB_ = newPTB;
            idxToPTB_ = 0;
            this->R_++;
        }
        return PTB_[idxToPTB_++];
    }

private:
    std::vector<std::vector<bool>> PTB_; 
    std::vector<bool> curPTB_;
    unsigned table_ = 0;
};
